        -:    0:Source:/home/cheg/Repos/Master/SpikeLibrary/src/neurons.c
        -:    0:Graph:/home/cheg/Repos/Master/SpikeLibrary/cmake-build-debug/src/CMakeFiles/spike.dir/neurons.c.gcno
        -:    0:Data:/home/cheg/Repos/Master/SpikeLibrary/cmake-build-debug/src/CMakeFiles/spike.dir/neurons.c.gcda
        -:    0:Runs:1
        -:    1:#include "neurons.h"
        -:    2:#include <gsl/gsl_randist.h>
        -:    3:#include <math.h>
        -:    4:
    #####:    5:void get_spike_train_lif(const gsl_rng *r, const if_params_t *if_params,
        -:    6:                         const time_frame_t *time_frame,
        -:    7:                         spike_train_t *spike_train) {
        -:    8:  // initial values
    #####:    9:  double v = 0.;
        -:   10:
    #####:   11:  double dt = time_frame->dt;
        -:   12:
    #####:   13:  for (int i = 0; i < time_frame->N; i++) {
    %%%%%:   13-block  0
    %%%%%:   13-block  1
    %%%%%:   13-block  2
    #####:   14:    v += (if_params->mu - v) * dt +
    #####:   15:         sqrt(2.0 * if_params->D) * gsl_ran_gaussian(r, sqrt(dt));
    %%%%%:   15-block  0
    #####:   16:    if (v > 1.0) {
    #####:   17:      v = 0.;
    #####:   18:      spike_train->data[i] = true;
    %%%%%:   18-block  0
        -:   19:    }
        -:   20:  }
    #####:   21:}
        -:   22:
    #####:   23:void get_spike_train_lif_signal(const gsl_rng *r, const if_params_t *if_params,
        -:   24:                                const double *signal,
        -:   25:                                const time_frame_t *time_frame,
        -:   26:                                spike_train_t *spike_train) {
        -:   27:  // initial values
    #####:   28:  double v = 0.;
        -:   29:
    #####:   30:  double dt = time_frame->dt;
        -:   31:
    #####:   32:  for (int i = 0; i < time_frame->N; i++) {
    %%%%%:   32-block  0
    %%%%%:   32-block  1
    %%%%%:   32-block  2
    #####:   33:    v += (if_params->mu - v + signal[i]) * dt +
    #####:   34:         sqrt(2.0 * if_params->D) * gsl_ran_gaussian(r, sqrt(dt));
    %%%%%:   34-block  0
    #####:   35:    if (v > 1.0) {
    #####:   36:      v = 0.;
    #####:   37:      spike_train->data[i] = true;
    %%%%%:   37-block  0
        -:   38:    }
        -:   39:  }
    #####:   40:}
        -:   41:
    #####:   42:void get_spike_train_pif(const gsl_rng *r, const if_params_t *if_params,
        -:   43:                         const time_frame_t *time_frame,
        -:   44:                         spike_train_t *spike_train) {
        -:   45:  // initial values
    #####:   46:  double v = 0.;
        -:   47:
    #####:   48:  double dt = time_frame->dt;
        -:   49:
    #####:   50:  for (int i = 0; i < time_frame->N; i++) {
    %%%%%:   50-block  0
    %%%%%:   50-block  1
    %%%%%:   50-block  2
    #####:   51:    v += if_params->mu * dt +
    #####:   52:         sqrt(2.0 * if_params->D) * gsl_ran_gaussian(r, sqrt(dt));
    %%%%%:   52-block  0
    #####:   53:    if (v > 1.0) {
    #####:   54:      v = 0.;
    #####:   55:      spike_train->data[i] = true;
    %%%%%:   55-block  0
        -:   56:    }
        -:   57:  }
    #####:   58:}
        -:   59:
    #####:   60:void get_spike_train_pif_signal(const gsl_rng *r, const if_params_t *if_params,
        -:   61:                                const double *signal,
        -:   62:                                const time_frame_t *time_frame,
        -:   63:                                spike_train_t *spike_train) {
        -:   64:  // initial values
    #####:   65:  double v = 0.;
        -:   66:
    #####:   67:  double dt = time_frame->dt;
        -:   68:
    #####:   69:  for (int i = 0; i < time_frame->N; i++) {
    %%%%%:   69-block  0
    %%%%%:   69-block  1
    %%%%%:   69-block  2
    #####:   70:    v += (if_params->mu + signal[i]) * dt +
    #####:   71:         sqrt(2.0 * if_params->D) * gsl_ran_gaussian(r, sqrt(dt));
    %%%%%:   71-block  0
    #####:   72:    if (v > 1.0) {
    #####:   73:      v = 0.;
    #####:   74:      spike_train->data[i] = true;
    %%%%%:   74-block  0
        -:   75:    }
        -:   76:  }
    #####:   77:}
        -:   78:
    #####:   79:void get_spike_train_lifac(const gsl_rng *r, const ifac_params_t *ifac_params,
        -:   80:                           const time_frame_t *time_frame,
        -:   81:                           spike_train_t *spike_train) {
        -:   82:  // initial values
    #####:   83:  double v = 0.;
    #####:   84:  double a = 0.;
        -:   85:
    #####:   86:  double dt = time_frame->dt;
        -:   87:
    #####:   88:  for (int i = 0; i < time_frame->N; i++) {
    %%%%%:   88-block  0
    %%%%%:   88-block  1
    %%%%%:   88-block  2
    #####:   89:    v += (ifac_params->mu - v - a) * dt +
    #####:   90:         sqrt(2.0 * ifac_params->D) * gsl_ran_gaussian(r, sqrt(dt));
    %%%%%:   90-block  0
    #####:   91:    a += -1. / ifac_params->tau_a * a * dt;
    #####:   92:    if (v > 1.0) {
    #####:   93:      v = 0.;
    #####:   94:      a += ifac_params->Delta;
    #####:   95:      spike_train->data[i] = true;
    %%%%%:   95-block  0
        -:   96:    }
        -:   97:  }
    #####:   98:}
        -:   99:
    #####:  100:void get_spike_train_lifac_signal(const gsl_rng *r,
        -:  101:                                  const ifac_params_t *ifac_params,
        -:  102:                                  const double *signal,
        -:  103:                                  const time_frame_t *time_frame,
        -:  104:                                  spike_train_t *spike_train) {
        -:  105:  // initial values
    #####:  106:  double v = 0.;
    #####:  107:  double a = 0.;
        -:  108:
    #####:  109:  double dt = time_frame->dt;
        -:  110:
    #####:  111:  for (int i = 0; i < time_frame->N; i++) {
    %%%%%:  111-block  0
    %%%%%:  111-block  1
    %%%%%:  111-block  2
    #####:  112:    v += (ifac_params->mu - v - a + signal[i]) * dt +
    #####:  113:         sqrt(2.0 * ifac_params->D) * gsl_ran_gaussian(r, sqrt(dt));
    %%%%%:  113-block  0
    #####:  114:    a += -1. / ifac_params->tau_a * a * dt;
    #####:  115:    if (v > 1.0) {
    #####:  116:      v = 0.;
    #####:  117:      a += ifac_params->Delta;
    #####:  118:      spike_train->data[i] = true;
    %%%%%:  118-block  0
        -:  119:    }
        -:  120:  }
    #####:  121:}
        -:  122:
    #####:  123:void get_spike_train_pifac(const gsl_rng *r, const ifac_params_t *ifac_params,
        -:  124:                           const time_frame_t *time_frame,
        -:  125:                           spike_train_t *spike_train) {
        -:  126:  // initial values
    #####:  127:  double v = 0.;
    #####:  128:  double a = 0.;
        -:  129:
    #####:  130:  double dt = time_frame->dt;
        -:  131:
    #####:  132:  for (int i = 0; i < time_frame->N; i++) {
    %%%%%:  132-block  0
    %%%%%:  132-block  1
    %%%%%:  132-block  2
    #####:  133:    v += (ifac_params->mu - a) * dt +
    #####:  134:         sqrt(2.0 * ifac_params->D) * gsl_ran_gaussian(r, sqrt(dt));
    %%%%%:  134-block  0
    #####:  135:    a += -1. / ifac_params->tau_a * a * dt;
    #####:  136:    if (v > 1.0) {
    #####:  137:      v = 0.;
    #####:  138:      a += ifac_params->Delta;
    #####:  139:      spike_train->data[i] = true;
    %%%%%:  139-block  0
        -:  140:    }
        -:  141:  }
    #####:  142:}
        -:  143:
    #####:  144:void get_spike_train_pifac_signal(const gsl_rng *r,
        -:  145:                                  const ifac_params_t *ifac_params,
        -:  146:                                  const double *signal,
        -:  147:                                  const time_frame_t *time_frame,
        -:  148:                                  spike_train_t *spike_train) {
        -:  149:  // initial values
    #####:  150:  double v = 0.;
    #####:  151:  double a = 0.;
        -:  152:
    #####:  153:  double dt = time_frame->dt;
        -:  154:
    #####:  155:  for (int i = 0; i < time_frame->N; i++) {
    %%%%%:  155-block  0
    %%%%%:  155-block  1
    %%%%%:  155-block  2
    #####:  156:    v += (ifac_params->mu - a + signal[i]) * dt +
    #####:  157:         sqrt(2.0 * ifac_params->D) * gsl_ran_gaussian(r, sqrt(dt));
    %%%%%:  157-block  0
    #####:  158:    a += -1. / ifac_params->tau_a * a * dt;
    #####:  159:    if (v > 1.0) {
    #####:  160:      v = 0.;
    #####:  161:      a += ifac_params->Delta;
    #####:  162:      spike_train->data[i] = true;
    %%%%%:  162-block  0
        -:  163:    }
        -:  164:  }
    #####:  165:}
